<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>C++ 基础和进阶笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="序言C++巩固笔记 1. 构造函数和析构函数(1) 构造函数12345678910@ 与类的名称完全相同@ 特殊的成员函数 @ 默认无参，支持传参@ 没有返回值类型，也没有返回值，不能返回void@ 创建对象实例时执行@ 构造函数不能显示调用@ 构造函数可以在类内或类外定义@ 构造函数支持重载：一个类可以有多个构造函数，通过形参个数和类型区分@ 构造函数内不能做任何有可能失败的操作，比如执行MML">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 基础和进阶笔记">
<meta property="og:url" content="http://yoursite.com/2020/07/18/C++%20%E5%9F%BA%E7%A1%80%E5%92%8C%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="序言C++巩固笔记 1. 构造函数和析构函数(1) 构造函数12345678910@ 与类的名称完全相同@ 特殊的成员函数 @ 默认无参，支持传参@ 没有返回值类型，也没有返回值，不能返回void@ 创建对象实例时执行@ 构造函数不能显示调用@ 构造函数可以在类内或类外定义@ 构造函数支持重载：一个类可以有多个构造函数，通过形参个数和类型区分@ 构造函数内不能做任何有可能失败的操作，比如执行MML">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200718153954680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM1NjkyNjI4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200718154047965.png">
<meta property="article:published_time" content="2020-07-18T08:50:10.733Z">
<meta property="article:modified_time" content="2020-07-18T09:11:38.548Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200718153954680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM1NjkyNjI4,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C++ 基础和进阶笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/18/C++%20%E5%9F%BA%E7%A1%80%E5%92%8C%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-18T08:50:10.733Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ 基础和进阶笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>C++巩固笔记</p>
<h1 id="1-构造函数和析构函数"><a href="#1-构造函数和析构函数" class="headerlink" title="1. 构造函数和析构函数"></a>1. 构造函数和析构函数</h1><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="(1) 构造函数"></a>(1) 构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ 与类的名称完全相同</span><br><span class="line">@ 特殊的成员函数 </span><br><span class="line">@ 默认无参，支持传参</span><br><span class="line">@ 没有返回值类型，也没有返回值，不能返回<span class="keyword">void</span></span><br><span class="line">@ 创建对象实例时执行</span><br><span class="line">@ 构造函数不能显示调用</span><br><span class="line">@ 构造函数可以在类内或类外定义</span><br><span class="line">@ 构造函数支持重载：一个类可以有多个构造函数，通过形参个数和类型区分</span><br><span class="line">@ 构造函数内不能做任何有可能失败的操作，比如执行MML命令等</span><br><span class="line">@ 严禁在构造函数中创建线程，仅作成员变量的初始化工作，其他操作通过成员函数完成</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数的作用<ul>
<li>给新建对象建立一个标识符</li>
<li>为对象数据开辟内存空间</li>
<li>完成对象数据成员的初始化</li>
</ul>
</li>
<li>注意<ul>
<li>默认构造函数不能完成对象数据成员的初始化</li>
</ul>
</li>
</ul>
<h2 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="(2) 析构函数"></a>(2) 析构函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ 与类的名称完全相同，前面加波浪号~</span><br><span class="line">@ 特殊的成员函数</span><br><span class="line">@ 与构造函数不同，不能带有任何参数</span><br><span class="line">@ 不会返回任何值</span><br><span class="line">@ 删除对象实例时执行，在跳出程序前释放资源</span><br><span class="line">@ 析构函数只能有一个，不能被重载</span><br><span class="line">@ 不同于构造函数，析构函数可以被显示调用：Instance.~xigouFun();</span><br></pre></td></tr></table></figure>
<ul>
<li>注意<ul>
<li>默认西沟函数只能释放普通数据成员所占空间，无法释放通过new/malloc申请的空间</li>
</ul>
</li>
</ul>
<h1 id="2-类的定义与实现"><a href="#2-类的定义与实现" class="headerlink" title="2. 类的定义与实现"></a>2. 类的定义与实现</h1><h2 id="1-抽象"><a href="#1-抽象" class="headerlink" title="(1) 抽象"></a>(1) 抽象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ 类 = 属性 + 方法</span><br><span class="line">@ 类：基类-派生类 or 父类-子类</span><br><span class="line">@ <span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">protected</span>是属性/方法限制的关键字，出现顺序任意</span><br><span class="line">@ 封装：尽量隐藏类的内部实现，只向用户提供有用的成员函数</span><br></pre></td></tr></table></figure>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="(2) 实现"></a>(2) 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ 类定义结束加分号；与结构体定义一致</span><br><span class="line">@ 实现：类内 or 类外</span><br><span class="line">  类外定义成员函数：</span><br><span class="line">  returnType ClassName::MemberFunc(arg1, arg2, ...) &#123;&#125;</span><br><span class="line">@ 类内定义时编译器会默认争取将方法定义为inline内联函数</span><br></pre></td></tr></table></figure>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="(3) 使用"></a>(3) 使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ 实例化：创建类的对象</span><br><span class="line">@ 访问：</span><br><span class="line">  访问属性：对象名.<span class="keyword">public</span>数据成员</span><br><span class="line">  访问方法：对象名.<span class="keyword">public</span>函数名(参数列表)</span><br><span class="line">@ 类对象的作用域、可见域以及生存周期与普通变量相同</span><br><span class="line">@ <span class="keyword">new</span> 或 malloc 申请的动态内存需要手动清理，避免内存泄漏</span><br><span class="line">@ 尽量避免定义<span class="keyword">public</span>成员：考虑类的功能，尽量减少对外接口的暴露</span><br><span class="line">@ 在类中声明并定义的成员函数，自动转换为内联函数</span><br></pre></td></tr></table></figure>
<h1 id="3-继承和派生"><a href="#3-继承和派生" class="headerlink" title="3. 继承和派生"></a>3. 继承和派生</h1><h2 id="1-类成员的访问权限"><a href="#1-类成员的访问权限" class="headerlink" title="(1) 类成员的访问权限"></a>(1) 类成员的访问权限</h2><table>
<thead>
<tr>
<th align="center">访问\权限</th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基类</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">派生类</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"><font color=#ff00><strong>No</strong></font></td>
</tr>
<tr>
<td align="center">外部类</td>
<td align="center">Yes</td>
<td align="center"><font color=#ff00><strong>No</strong></font></td>
<td align="center"><font color=#ff00><strong>No</strong></font></td>
</tr>
<tr>
<td align="center">友元类/函数</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">Yes</td>
<td align="center"><font color=#ff00><strong>No</strong></font></td>
<td align="center"><font color=#ff00><strong>No</strong></font></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span>：成员访问限定符</span><br><span class="line">    不写成员访问限定符，默认为<span class="keyword">private</span>。类体中访问父可以出现多次，建议一次</span><br><span class="line">[<span class="number">2</span>] 类内，<span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span>可以互相访问，没有访问权限的限制</span><br><span class="line">[<span class="number">3</span>] <span class="keyword">private</span>成员：只能在基类内或通过友元函数访问，不能通过对象访问</span><br><span class="line">[<span class="number">4</span>] <span class="keyword">protected</span>成员：在基类内/派生类内/友元函数访问，不能通过对象访问</span><br><span class="line">[<span class="number">5</span>] 基类对象不能直接访问基类的私有成员，否则破坏了信息隐藏的目的</span><br><span class="line">[<span class="number">6</span>] 基类对象可以通过基类<span class="keyword">public</span>/<span class="keyword">protected</span>成员友元函数访问</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="2-公有继承-私有继承-保护继承"><a href="#2-公有继承-私有继承-保护继承" class="headerlink" title="(2) 公有继承/私有继承/保护继承"></a>(2) 公有继承/私有继承/保护继承</h2><ul>
<li>[1] 继承方式：<ul>
<li>public/protected/private继承，如果没有访问修饰符，默认为<strong>私有继承</strong></li>
<li>通常使用<strong>public</strong>继承，几乎不使用protected/private继承</li>
</ul>
</li>
<li>[2] 派生类继承的基类方法<ul>
<li>派生类继承了所有的基类方法，除了<ul>
<li>基类的<font color=#ff00><strong>构造函数</strong></font>、<font color=#ff00><strong>析构函数</strong></font>和<font color=#ff00><strong>拷贝构造函数</strong></font></li>
<li>基类的<font color=#ff00><strong>友元函数</strong></font></li>
<li>基类的<font color=#ff00><strong>重载运算符</strong></font></li>
</ul>
</li>
</ul>
</li>
<li>[3] 继承的权限变化</li>
</ul>
<table>
<thead>
<tr>
<th align="center">继承方式</th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公有继承</td>
<td align="center">public</td>
<td align="center">protected</td>
<td align="center"><font color=#ff00><strong>不可见</strong></font></td>
</tr>
<tr>
<td align="center">私有继承</td>
<td align="center">private</td>
<td align="center">private</td>
<td align="center"><font color=#ff00><strong>不可见</strong></font></td>
</tr>
<tr>
<td align="center">保护继承</td>
<td align="center">protected</td>
<td align="center">protected</td>
<td align="center"><font color=#ff00><strong>不可见</strong></font></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ 公有继承：基类的公有和保护成员可见，私有不可见。基类的私有成员可以通过基类的公有和派生成员来访问</span><br><span class="line">@ 私有继承：基类的公有和保护成员作为派生类的私有成员，派生类的派生类不可访问</span><br><span class="line">@ 保护继承：基类的公有和保护成员作为派生类的保护成员，派生类的成员和有源函数可访问</span><br></pre></td></tr></table></figure>
<ul>
<li>补充：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ 继承是权限收缩的过程</span><br><span class="line">@ <span class="keyword">public</span>继承不改变基类的访问权限</span><br><span class="line">@ 基类<span class="keyword">private</span>不受继承方式影响，派生类永远无权访问</span><br><span class="line">@ <span class="keyword">private</span>继承后，想恢复<span class="keyword">public</span>/<span class="keyword">protected</span>的访问权限，可通过两种方式</span><br><span class="line">  <span class="number">1</span>) 使用using语句</span><br><span class="line">  <span class="number">2</span>) 使用访问声明，base Class::member</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-派生类调用基类方法"><a href="#3-派生类调用基类方法" class="headerlink" title="(3) 派生类调用基类方法"></a>(3) 派生类调用基类方法</h2><ul>
<li>[1] 派生类调用基类普通成员函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	d.show();		<span class="comment">// 运行的是派生类的show()函数</span></span><br><span class="line"></span><br><span class="line">	d.Base::show();	<span class="comment">// 运行的是基类的show()函数</span></span><br><span class="line">	</span><br><span class="line">	Base b;			<span class="comment">// 基类直接生成实例</span></span><br><span class="line">	b.show();		<span class="comment">// 运行的是基类的show()函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[2] 派生类调用基类静态成员函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.func1();</span><br><span class="line">	A::func2();		<span class="comment">// 静态方法</span></span><br><span class="line">	</span><br><span class="line">	A *a;</span><br><span class="line">	a = <span class="keyword">new</span> B;</span><br><span class="line">	a-&gt;func1();</span><br><span class="line">	a-&gt;func2();		<span class="comment">// 静态方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-多继承和虚继承"><a href="#4-多继承和虚继承" class="headerlink" title="(4) 多继承和虚继承"></a>(4) 多继承和虚继承</h2><ul>
<li>继承方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class C : public A, public B &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>举例<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;D, B-&gt;D, C-&gt;(A,B)，多继承方式：</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;...&#125;;</span><br><span class="line">	class A : public D &#123;...&#125;;</span><br><span class="line">	class B : public D &#123;...&#125;;</span><br><span class="line">	class C : public A, public B &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">继承时会使D创建两个对象，可使用虚继承</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;...&#125;;</span><br><span class="line">	class A : virtual public D &#123;...&#125;;</span><br><span class="line">	class B : virtual public D &#123;...&#125;;</span><br><span class="line">	class C : public A, public B &#123;...&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="4-静态类-静态成员变量-静态成员函数"><a href="#4-静态类-静态成员变量-静态成员函数" class="headerlink" title="4. 静态类/静态成员变量/静态成员函数"></a>4. 静态类/静态成员变量/静态成员函数</h1><h2 id="1-静态类"><a href="#1-静态类" class="headerlink" title="(1) 静态类"></a>(1) 静态类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ 只用于包含静态成员的类型，不能进行实例化</span><br><span class="line">@ 为什么要有静态类：防止继承，防止外部进行<span class="keyword">new</span>操作</span><br><span class="line">@ 静态类用于无需创建类实例就能访问的数据和函数</span><br><span class="line">@ 静态类成员可用于分离任何对象标识的数据和行为，对象变更不会影响这些数据和函数</span><br><span class="line">  当类中没有依赖对象的数据和行为，就可以使用静态类</span><br><span class="line">  当一个类完全脱离实例数据和对象时就可以使用静态类</span><br><span class="line"> @ 静态类可以有自己的成员变量和函数，但都必须是静态的</span><br><span class="line"> @ 静态类没有基类</span><br></pre></td></tr></table></figure>

<h2 id="2-静态成员变量"><a href="#2-静态成员变量" class="headerlink" title="(2) 静态成员变量"></a>(2) 静态成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ 类内<span class="keyword">static</span>关键字修饰，初始化时不能再加<span class="keyword">static</span></span><br><span class="line">@ 静态成员变量和普通静态变量一样，存储在全局区，不占用对象内存，用于数据共享</span><br><span class="line">@ 静态成员变量属于类，但不属于具体的对象，所有对象均可访问</span><br><span class="line">@ 静态成员变量只能在类外初始化，不能在类内初始化。没有类外初始化的<span class="keyword">static</span>变量不能使用</span><br></pre></td></tr></table></figure>

<h2 id="3-静态成员函数"><a href="#3-静态成员函数" class="headerlink" title="(3) 静态成员函数"></a>(3) 静态成员函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ 类内<span class="keyword">static</span>关键字修饰，类外定义时不能加<span class="keyword">static</span></span><br><span class="line">@ 静态成员函数不能访问对象的成员，只能访问静态成员变量和静态成员函数</span><br><span class="line">  原因：编译器不会为静态成员函数分配<span class="keyword">this</span>指针</span><br><span class="line">@ 与静态成员变量一样，不管有没有创建对象，都可以调用静态成员函数</span><br><span class="line">  原因：没有<span class="keyword">this</span>指针，无法在函数体内部访问某个对象，包括变量和函数</span><br><span class="line">@ 静态成员函数和普通成员函数的根本区别</span><br><span class="line">  普通成员函数：有<span class="keyword">this</span>指针，可以访问类中任意成员</span><br><span class="line">  静态成员函数：没有<span class="keyword">this</span>指针，只能访问静态成员</span><br></pre></td></tr></table></figure>

<h1 id="5-友元函数"><a href="#5-友元函数" class="headerlink" title="5. 友元函数"></a>5. 友元函数</h1><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="(1) 使用场景"></a>(1) 使用场景</h2><ul>
<li>友元函数破坏了封装机制，除非不得已的情况下才使用<ul>
<li>[1] 两个类要共享数据时</li>
<li>[2] <strong>运算符重载</strong>的某些场合要使用友元</li>
</ul>
</li>
</ul>
<h2 id="2-友元函数参数"><a href="#2-友元函数参数" class="headerlink" title="(2) 友元函数参数"></a>(2) 友元函数参数</h2><ul>
<li>友元函数没有this指针<ul>
<li>[1] 访问非static成员，对象做参数</li>
<li>[2] 访问static成员或全局变量，不需要对象做参数</li>
<li>[3] 参数是全局对象，不需要对象做参数</li>
</ul>
</li>
</ul>
<h2 id="3-友元函数的位置"><a href="#3-友元函数的位置" class="headerlink" title="(3) 友元函数的位置"></a>(3) 友元函数的位置</h2><ul>
<li>类内可放在私有或公有，没有区别，通常写为<strong>私有</strong></li>
<li>能访问protected和private成员</li>
</ul>
<h2 id="4-与普通成员函数的区别"><a href="#4-与普通成员函数的区别" class="headerlink" title="(4) 与普通成员函数的区别"></a>(4) 与普通成员函数的区别</h2><ul>
<li>普通成员函数有this指针，友元函数没有this指针</li>
<li>友元函数不能被继承</li>
<li>友元函数不是当前类的成员函数，而是独立于类的外部函数</li>
</ul>
<h1 id="6-重载：函数重载和运算符重载"><a href="#6-重载：函数重载和运算符重载" class="headerlink" title="6. 重载：函数重载和运算符重载"></a>6. 重载：函数重载和运算符重载</h1><p>选择最合适的重载函数或重载运算符的过程，称为重载决策</p>
<h2 id="1-函数重载"><a href="#1-函数重载" class="headerlink" title="(1) 函数重载"></a>(1) 函数重载</h2><ul>
<li>功能类似的同名函数，参数个数、类型或者顺序必须不同，包括返回类型</li>
<li>构造函数支持重载，通过参数个数、类型或顺序来区分</li>
</ul>
<h2 id="2-运算符重载"><a href="#2-运算符重载" class="headerlink" title="(2) 运算符重载"></a>(2) 运算符重载</h2><ul>
<li>[1] 什么是运算符重载：本质是一个函数，通过运算符重载重新定义运算符的使用</li>
<li>[2] 可重载和不可重载运算符<br>可重载运算符：<br><img src="https://img-blog.csdnimg.cn/20200718153954680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM1NjkyNjI4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>不可重载运算符：<br><img src="https://img-blog.csdnimg.cn/20200718154047965.png" alt="在这里插入图片描述"></li>
<li>[3] 运算符重载格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType operator 运算符 (参数)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespave std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">// 友元函数形式实现运算符重载</span></span><br><span class="line">	friend Demo &amp; operator+ (Demo &amp;demo, <span class="keyword">int</span> n);</span><br><span class="line">	Demo (<span class="keyword">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载"+"运算符</span></span><br><span class="line">Demo &amp; operator+ (Demo &amp;demo, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	demo.a += n;</span><br><span class="line">	<span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Demo <span class="title">demo</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 重载"+"运算符后，对象可以直接加一个数</span></span><br><span class="line">	demo = demo + <span class="number">2</span>;</span><br><span class="line">	cout&lt;&lt;demo.GetA()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>补充：<ul>
<li>构造函数支持重载，但不支持运算符重载</li>
<li>重载不会改变运算符的操作对象（双目仍然是双目），也不会改变运算符原有的优先级和结合性</li>
<li>C++支持运算符重载可能是为了与内置数据类型统一操作，add(a, b)和a + b</li>
</ul>
</li>
</ul>
<h1 id="7-函数调用"><a href="#7-函数调用" class="headerlink" title="7. 函数调用"></a>7. 函数调用</h1><h2 id="1-成员函数调用格式"><a href="#1-成员函数调用格式" class="headerlink" title="(1) 成员函数调用格式"></a>(1) 成员函数调用格式</h2><ul>
<li>C++中，类对象定义为：指针对象 || 一般对象<ul>
<li>指针对象：”-&gt;”访问类中成员</li>
<li>一般对象：”.”访问类中成员<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	A *p;</span><br><span class="line">	p-&gt;func();</span><br><span class="line">	(*p).func();</span><br><span class="line">	</span><br><span class="line">	A p;</span><br><span class="line">	p.func();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="2-类内成员函数之间访问"><a href="#2-类内成员函数之间访问" class="headerlink" title="(2) 类内成员函数之间访问"></a>(2) 类内成员函数之间访问</h2><ul>
<li>调用public成员：<ul>
<li>[1] 直接调用：OtherMemberFunc();</li>
<li>[2] 类作用域调用：class::OtherMemberFunc();</li>
<li>[3] 类对象调用：class inst; inst.OtherMemberFunc();</li>
</ul>
</li>
<li>调用private成员：<ul>
<li>[1] 直接调用：privateVar;</li>
<li>[2] 类作用域调用：class:privateVar;</li>
</ul>
</li>
</ul>
<h2 id="3-不同类之间成员函数的访问"><a href="#3-不同类之间成员函数的访问" class="headerlink" title="(3) 不同类之间成员函数的访问"></a>(3) 不同类之间成员函数的访问</h2><ul>
<li>对象实例化引用,private通过public成员调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> B::DoSomething()</span><br><span class="line">&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.PrintMe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="8-虚函数和纯虚函数"><a href="#8-虚函数和纯虚函数" class="headerlink" title="8. 虚函数和纯虚函数"></a>8. 虚函数和纯虚函数</h1><h2 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="(1) 虚函数"></a>(1) 虚函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ 虚函数存在的唯一目的是为了实现多态</span><br><span class="line">@ 声明：<span class="function">virtual returnType <span class="title">Function</span><span class="params">()</span></span>;</span><br><span class="line">@ “推迟联编/动态联编”：编写代码的时候不能确定被调用哪个的是基类的函数还是那个派生类的函数，所以称为虚函数</span><br><span class="line">@ 基类虚函数必须实现，否则链接时会报错</span><br><span class="line">@ 虚函数，基类和派生类各有版本，多态方式动态绑定</span><br><span class="line">@ 虚函数重写：基类中可以是<span class="keyword">private</span>，派生类中可以是<span class="keyword">public</span>或<span class="keyword">protected</span></span><br></pre></td></tr></table></figure>

<h2 id="2-纯虚函数"><a href="#2-纯虚函数" class="headerlink" title="(2) 纯虚函数"></a>(2) 纯虚函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ 定义纯虚函数的目的在于：使派生类仅仅继承函数的接口；</span><br><span class="line">@ 纯虚函数引入是为了解决“要使用动态特性，但基类本身生成对象不合理”的情况，如动物类实例</span><br><span class="line">@ 声明：<span class="function">virtual returnType <span class="title">Function</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  纯虚函数的声明在于告诉派生类设计者：你必须提供一个纯虚函数的实现，但我不知道你会怎么实现它</span><br></pre></td></tr></table></figure>

<h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="(3) 抽象类"></a>(3) 抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ 声明了纯虚函数的类是一个抽象类</span><br><span class="line">@ 抽象类不能定义对象/实例，但可以声明只想该抽象类的具体类的指针或引用</span><br><span class="line">@ 抽象类作为基类，纯虚函数的实现由派生类给出，如果派生类未重新定义纯虚函数只是继承，则派生类仍然是一个抽象类，而不是一个具体的类</span><br><span class="line">@ 派生类实现纯虚函数后，该纯虚函数在派生类中就变成了虚函数，派生类的派生类可重新该函数</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类实例化报错：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: cannot declare varible <span class="string">'inst'</span> to be of <span class="keyword">abstract</span> type <span class="string">'Class'</span></span><br><span class="line">note: because the following virtual funcs are pure with <span class="string">'Class'</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="9-命名空间-using-namespace-std"><a href="#9-命名空间-using-namespace-std" class="headerlink" title="9. 命名空间 using namespace std;"></a>9. 命名空间 using namespace std;</h1><ul>
<li>使用一个名为std的命名空间</li>
<li>(1) 作用：<ul>
<li>[1] 避免命名冲突：避免与标准库标识符命名冲突</li>
<li>[2] 使用命名空间中的地故意和声明的所有标识符，如std中cin/cout/endl/hex/函数等。std中定义和声明的所欲标识符在本文件冲都可以作为全局变量使用</li>
</ul>
</li>
</ul>
<h1 id="10-…-后是否加分号问题"><a href="#10-…-后是否加分号问题" class="headerlink" title="10. {…}后是否加分号问题"></a>10. {…}后是否加分号问题</h1><ul>
<li>(1) 一句话总结：<strong>语句</strong>、<strong>定义</strong>不需要分号结尾，<strong>声明</strong>需要分号结尾</li>
<li>(2) 使用举例<ul>
<li>[1] 语句：while/for/if语句不用加分号，{}本身是语句的一部分</li>
<li>do {…} while(1); 执行语句后判断是否执行下一次循环，}不能代表结尾，需要加分号</li>
<li>[2] 定义：函数定义，{}不需要加分号</li>
<li>[3] 声明：结构体、枚举、类定义是声明，所以需要分号结尾，类似变量int a;</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2020.07.18 create by shuaixio</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/18/C++%20%E5%9F%BA%E7%A1%80%E5%92%8C%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/" data-id="ckcrfd0e70000o4cmhht93b8n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/19/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C++ 字符串操作函数使用总结
        
      </div>
    </a>
  
  
    <a href="/2020/06/26/Python-%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%B9%B6%E7%BB%9F%E8%AE%A1%E5%85%B6%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0-%E5%B0%8F%E7%A8%8B%E5%BA%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Python-读取目录下所有文件并统计其代码行数-小程序</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/02/C++%20gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">C++ gdb常用命令汇总</a>
          </li>
        
          <li>
            <a href="/2020/07/26/C++%20vector%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/">C++ vector数组操作函数总结</a>
          </li>
        
          <li>
            <a href="/2020/07/19/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">C++ 字符串操作函数使用总结</a>
          </li>
        
          <li>
            <a href="/2020/07/18/C++%20%E5%9F%BA%E7%A1%80%E5%92%8C%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/">C++ 基础和进阶笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/26/Python-%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%B9%B6%E7%BB%9F%E8%AE%A1%E5%85%B6%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0-%E5%B0%8F%E7%A8%8B%E5%BA%8F/">Python-读取目录下所有文件并统计其代码行数-小程序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>